// src/app/api/properties/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { z } from "zod";
import {
  PROPERTY_TYPES,
  PURPOSES,
  STATUSES,
  DIRECTIONS,
  LEGALS,
  valuesOf,
} from "@/constants/bdsOptions";

// B·∫Øt Next kh√¥ng cache tƒ©nh & ƒë·∫£m b·∫£o ch·∫°y Node runtime
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

/**
 * Chu·∫©n ho√° "purpose" n·∫øu client l·ª° g·ª≠i nh√£n ti·∫øng Vi·ªát:
 * "ban"/"b√°n"  -> "buy"
 * "cho-thue"/"cho thu√™"/"thue" -> "rent"
 */
const PurposeEnum = z.enum(valuesOf(PURPOSES));
const PurposeSchema = z.preprocess((v) => {
  if (typeof v === "string") {
    const s = v.trim().toLowerCase();
    if (s === "ban" || s === "b√°n") return "buy";
    if (s === "cho-thue" || s === "cho thu√™" || s === "thue" || s === "thu√™") return "rent";
  }
  return v;
}, PurposeEnum);

/** Th√¥ng s·ªë k·ªπ thu·∫≠t cho BƒêS c√¥ng nghi·ªáp (tu·ª≥ ch·ªçn) */
const SpecsSchema = z
  .object({
    powerKva: z.coerce.number().positive().optional(),       // ƒêi·ªán 3 pha (kVA)
    floorLoad: z.coerce.number().positive().optional(),      // T·∫£i s√†n (t·∫•n/m¬≤)
    clearHeight: z.coerce.number().positive().optional(),    // Cao th√¥ng thu·ª∑ (m)
    dockDoors: z.coerce.number().int().min(0).optional(),    // S·ªë c·ª≠a/dock
    roadWidth: z.coerce.number().positive().optional(),      // L·ªô gi·ªõi (m)
    officeRatio: z.coerce.number().min(0).max(100).optional()// % di·ªán t√≠ch vƒÉn ph√≤ng
  })
  .partial()
  .strict();

const PropertySchema = z.object({
  title: z.string().trim().min(3),
  description: z.string().trim().min(10),
  price: z.coerce.number().positive(),
  area: z.coerce.number().positive(),
  address: z.string().trim().min(3),

  // L∆∞u slug v·ªã tr√≠
  ward: z.string().trim().optional().nullable(),
  district: z.string().trim().optional().nullable(),
  city: z.string().trim().optional().nullable(),

  propertyType: z.enum(valuesOf(PROPERTY_TYPES)),
  purpose: PurposeSchema, // d√πng schema ƒë√£ chu·∫©n ho√° ·ªü tr√™n
  status: z.enum(valuesOf(STATUSES)),

  bedrooms: z.coerce.number().int().optional().nullable(),
  bathrooms: z.coerce.number().int().optional().nullable(),
  floors: z.coerce.number().int().optional().nullable(),

  legal: z.enum(valuesOf(LEGALS)).optional().nullable(),
  direction: z.enum(valuesOf(DIRECTIONS)).optional().nullable(),

  highlights: z.array(z.string()).optional().default([]),
  images: z.array(z.string().url()).min(1),

  userId: z.string().trim().optional().nullable(),
  projectSlug: z.string().trim().optional().nullable(), // slug d·ª± √°n

  // üëá Th√¥ng s·ªë c√¥ng nghi·ªáp (ch·ªâ g·ª≠i khi c·∫ßn)
  specs: SpecsSchema.optional(),
});

// GET: tr·∫£ danh s√°ch property m·ªõi nh·∫•t tr∆∞·ªõc
export async function GET() {
  try {
    const properties = await prisma.property.findMany({
      orderBy: { postedAt: "desc" },
    });
    return NextResponse.json(properties, { status: 200 });
  } catch (error) {
    console.error("L·ªói khi l·∫•y danh s√°ch b·∫•t ƒë·ªông s·∫£n:", error);
    return NextResponse.json(
      { error: "Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu" },
      { status: 500 }
    );
  }
}

// POST: t·∫°o property m·ªõi
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate & chu·∫©n ho√° d·ªØ li·ªáu theo schema
    const data = PropertySchema.parse(body);

    const created = await prisma.property.create({ data });
    return NextResponse.json(created, { status: 201 });
  } catch (err: any) {
    console.error("Create property error:", err);
    const message =
      err?.issues?.[0]?.message || err?.message || "Invalid payload";
    return NextResponse.json({ error: message }, { status: 400 });
  }
}
